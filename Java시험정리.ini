
JAVA 시험 답안

1. 변수 정의:

변수는 프로그램 내에서 값을 저장하기 위한 공간입니다. 변수 이름, 자료형, 값으로 구성됩니다.

2. final 예약어 작성 위치별 의미:

클래스 변수: 상수
인스턴스 변수: 객체 생성 후 변경 불가
메소드 매개변수: 메소드 내에서 값 변경 불가
지역 변수: 블록 내에서 값 변경 불가

3. 오버라이딩 정의 및 성립 조건:

정의: 상속 관계에서 하위 클래스가 상위 클래스의 메소드를 재정의하는 것
성립 조건:
메소드 이름, 매개변수, 반환형이 동일해야 함
접근 제한자가 상위 클래스 메소드보다 넓거나 같아야 함
throws 구문의 예외가 상위 클래스 메소드보다 같거나 적어야 함

4. 오버로딩 정의 및 성립 조건:

오버로딩 정의:

같은 클래스 내에서 메소드 이름이 동일하고 매개변수의 개수 또는 자료형이 다르거나 반환형이 다르는 메소드

성립 조건:

메소드 이름: 동일해야 함
매개변수:
개수 또는 자료형이 달라야 함
매개변수 순서는 오버로딩에 영향을 미치지 않습니다.
반환형:
다를 수도 있지만, 반환형만으로는 오버로딩을 구분할 수 없습니다.

5. 생성자:
생성자는 객체 생성 시 자동으로 호출되는 특별한 메서드입니다. 객체의 초기화 작업을 수행하며, 다음과 같은 특징을 갖습니다.

클래스 이름과 동일한 이름을 가집니다.
리턴 타입을 가지지 않습니다. (void도 사용하지 않습니다.)
매개변수를 가질 수 있습니다. (생성자 오버로딩 가능)
생성자의 역할:

객체의 필드 값을 초기화합니다.
다른 객체에 대한 참조를 설정합니다.
객체의 불변 속성을 설정합니다.
생성자의 종류:

기본 생성자: 매개변수가 없는 생성자
매개변수 생성자: 매개변수를 가진 생성자
생성자의 규칙:

클래스 이름과 동일한 이름을 가져야 합니다.
리턴 타입을 가지지 않아야 합니다.
접근 제한자를 가질 수 있습니다.
매개변수를 가질 수 있습니다. (매개변수 타입은 상이해야 함)
다른 생성자를 호출할 수 있습니다. (this() 키워드 사용)
오버라이딩될 수 있습니다.

6. 접근 제한자:

public: 모든 클래스에서 접근 가능
protected: 같은 패키지 및 하위 클래스에서 접근 가능
default: 같은 패키지에서 접근 가능
private: 클래스 내에서만 접근 가능

7. 기반 스트림 vs. 보조 스트림:

기반 스트림: 파일, 네트워크 등 데이터의 원천을 제공
보조 스트림: 기반 스트림에 데이터 입출력 기능 추가

8. 컬렉션 종류 및 특징:

List: 순서가 있는 데이터 저장
Set: 중복 허용하지 않고 데이터 저장
Map: 키-값 쌍으로 데이터 저장

9. 추상 메서드 및 추상 클래스:

추상 메서드:

메서드 구현 없이 선언만 하는 메서드
abstract 키워드를 사용하여 선언
하위 클래스에서 반드시 오버라이딩해야 함
추상 클래스:

추상 메서드를 하나라도 포함하는 클래스
abstract 키워드를 사용하여 선언
객체 생성 불가능
상속을 통해 기능 재사용 가능
추상 메서드 및 추상 클래스의 장점:

코드의 재사용성을 높임
코드의 결합도를 낮춤
코드의 확장성을 높임

10. 메소드 기능 설명:

각 메소드의 기능 상세 설명:
(a) boolean String.equals(Object anObject)

기능: 현재 문자열과 주어진 객체가 문자열로 동일한지 비교합니다.
매개변수:
anObject: 비교할 객체 (String 타입으로 변환 가능해야 함)
반환값:
true: 문자열이 동일
false: 문자열이 다름
참고: equals() 메소드는 객체의 참조를 비교하는 것이 아니라 문자열 내용을 비교합니다.
String 클래스는 compareTo() 메소드를 제공하여 문자열의 사전 순서를 비교할 수 있습니다.
(b) void ArrayList.add(int index, E e)

기능: ArrayList에 특정 위치에 요소를 추가합니다.
매개변수:
index: 요소를 추가할 위치 (0부터 시작)
e: 추가할 요소
반환값: 없음
참고:

add() 메소드는 인덱스를 지정하지 않으면 리스트 끝에 요소를 추가합니다.
ArrayList은 동적 배열이기 때문에 요소 추가 시 용량 자동 증가
(c) V HashMap.put(K key, V value)

기능: HashMap에 키-값 쌍을 추가합니다.
매개변수:
key: 키 객체
value: 값 객체
반환값:
이전에 같은 키로 저장된 값 (없으면 null)
참고:

put() 메소드는 이미 같은 키가 존재하면 기존 값을 덮어씁니다.
HashMap은 키-값 쌍을 저장하는데 빠르고 효율적인 데이터 구조입니다.
(d) String[] String.split(String regex)

기능: 문자열을 정규 표현식으로 분할하여 문자열 배열을 반환합니다.
매개변수:
regex: 분할 기준となる 정규 표현식
반환값: 분할된 문자열 배열
참고:

split() 메소드는 정규 표현식을 사용하여 다양한 기준으로 문자열을 분할할 수 있습니다.
Pattern 클래스를 사용하여 정규 표현식을 더욱 정교하게 정의할 수 있습니다.
(e) int HashSet.size():

기능: HashSet에 저장된 요소의 개수를 반환합니다.
매개변수: 없음
반환값: HashSet에 저장된 요소 개수
참고:

size() 메소드는 HashSet의 현재 크기를 빠르게 확인할 수 있도록 합니다.
isEmpty() 메소드는 HashSet이 비어있는지 확인하는데 사용할 수 있습니다.

11. 코드 에러 이유:

catch 블록 순서 오류 (IOException이 Exception보다 위에 있어야 함)
Exception은 모든 예외 처리 가능, IOException은 특정 예외만 처리

catch 블록은 상위 예외 클래스부터 하위 예외 클래스 순으로 작성해야 합니다. 현재 코드는 Exception이 IOException보다 위에 위치하여 에러가 발생합니다.


12. 문자열  배열  strArr을  생성하여  5개의  값을  기본  값이  아닌  임의의  값으로  초기화  하는  코드
를  작성하시오. (이  때,  초기화  데이터는  응시자  임의로  작성)

        String[] strArr = new String[5];

        strArr[0] = "a";
        strArr[1] = "b";
        strArr[2] = "c";
        strArr[3] = "d";
        strArr[4] = "e";

13. 객체 지향 프로그래밍의 4대 특징과 설명

객체 지향 프로그래밍(OOP)은 객체를 중심으로 프로그램을 설계하는 프로그래밍 패러다임입니다. 
객체는 데이터와 그 데이터를 처리하는 메소드를 함께 묶은 것입니다. OOP의 4대 특징은 다음과 같습니다.

13.1. 추상화

추상화는 객체의 본질적인 특징을 추출하여 모델링하는 과정입니다. 추상화를 통해 프로그램의 복잡성을 줄이고 이해하기 쉽게 만들 수 있습니다. 추상화는 다음과 같은 방법으로 이루어집니다.

클래스: 공통된 특징과 행위를 가진 객체들을 묶어 하나의 클래스로 정의합니다.
인터페이스: 객체가 제공해야 하는 메소드를 정의합니다.
상속: 한 클래스가 다른 클래스의 특징과 행위를 물려받는 기능입니다.

13.2. 캡슐화

캡슐화는 객체의 데이터와 메소드를 외부로부터 숨기고, 객체 내부에서만 사용하도록 하는 것입니다. 캡슐화를 통해 프로그램의 유지보수성을 향상시키고 코드의 재사용성을 높일 수 있습니다. 캡슐화는 다음과 같은 방법으로 이루어집니다.

접근 제어자: 객체의 데이터와 메소드에 대한 접근 권한을 제어합니다.
정보 은닉: 객체의 내부 구현 방식을 외부에 공개하지 않습니다.

13.3. 상속

상속은 한 클래스가 다른 클래스의 특징과 행위를 물려받는 기능입니다. 상속을 통해 코드의 재사용성을 높이고 프로그램의 유지보수성을 향상시킬 수 있습니다. 상속은 다음과 같은 방식으로 이루어집니다.

클래스 상속: 한 클래스가 다른 클래스를 상속받아 부모 클래스의 특징과 행위를 물려받습니다.
인터페이스 상속: 한 클래스가 인터페이스를 상속받아 인터페이스에서 정의된 메소드를 구현해야 합니다.
13.4. 다형성

다형성은 동일한 메소드가 상황에 따라 다르게 작동하는 기능입니다. 다형성을 통해 코드의 간결성을 높이고 프로그램의 유연성을 향상시킬 수 있습니다. 다형성은 다음과 같은 방식으로 이루어집니다.

오버라이딩: 상속받은 메소드를 자식 클래스에서 재정의하여 다르게 작동하도록 합니다.
오버로딩: 동일한 이름의 메소드를 매개변수의 개수나 타입에 따라 다르게 정의합니다.
객체 지향 프로그래밍의 장점
객체 지향 프로그래밍은 다음과 같은 장점을 가지고 있습니다.

코드의 재사용성 향상: 상속과 다형성을 통해 코드를 재사용할 수 있습니다.
유지보수성 향상: 캡슐화를 통해 코드를 이해하고 유지보수하기 쉽습니다.
확장성 향상: 추상화를 통해 프로그램을 쉽게 확장할 수 있습니다.
개발 생산성 향상: 객체 지향 프로그래밍은 개발자의 생산성을 향상시킬 수 있습니다.
객체 지향 프로그래밍의 단점
객체 지향 프로그래밍은 다음과 같은 단점을 가지고 있습니다.

복잡성 증가: 객체 지향 프로그래밍은 절차 지향 프로그래밍보다 복잡할 수 있습니다.
성능 저하: 객체 지향 프로그래밍은 절차 지향 프로그래밍보다 성능이 저하될 수 있습니다.
결론
객체 지향 프로그래밍은 많은 장점을 가지고 있지만, 단점도 존재합니다. 따라서 객체 지향 프로그래밍을 사용할 
때는 장점과 단점을 모두 고려하여 적절하게 사용해야 합니다.

14. 추상  클래스  B를  A에  상속하려고  한다.  빈칸에  알맞은  코드를  쓰시오. 

public class A extends B {}  

정답 : extends

15. 빈칸에 알맞은 단어를 쓰시오.
FileInputStream: 파일을 바이트 단위로 입력 받는 기반 스트림
FileOutputStream: 파일을 바이트 단위로 출력 하는 기반 스트림
ObjectOutputStream: 객체를 바이트 단위로 출력 하는 보조 스트림
ObjectInputStream: 객체를 바이트 단위로 입력 받는 보조 스트림

16. 빈칸에 알맞은 단어

Checked Exceptions: 반드시 예외 처리를 해야 하는 예외
Unchecked Exceptions: 예외 처리를 해주지 않아도 되는 예외

17. throws와  throw의  차이를  쓰시오.

throws는 예외를 던지는 메서드 선언에 사용되며, 예외 처리 책임을 호출한 곳으로 전가합니다.
throw는 예외를 직접 발생시키는 데 사용되며, 예외 처리 책임을 직접 처리하거나 호출한 곳으로 전가할 수 있습니다.

18. 
다음  코드를  수행했을  때  cc의  출력  결과를  작성하시오.  
String cc = "";   
int dd=50;    
switch (dd) { 
case 50: cc+='x'; 
case 30: cc+='y'; break; 
default: cc+='z';   
}  
System.out.println(cc); 
 
답  :  xy


switch 문에서 dd의 값을 비교합니다.
dd가 50과 같으면 cc에 x를 추가합니다.
case 30 문은 dd가 30인지 확인합니다.
dd가 30과 같으면 cc에 y를 추가합니다.
break 문은 실행되지 않습니다.
default 블록은 실행되지 않습니다.
마지막으로 cc의 값을 출력합니다.
따라서, cc의 출력 결과는 xy입니다.

19. 
아래  코드를  for문, switch문을  이용하여  같은  동작을  하는  코드로  변경하세요. 
 
  
String str = “banana”; 
int i = 0; 
while(i < str.length()){ 
char ch = str.charAt(i); 
if(ch == ‘a’ || ch == ‘e’ || ch == ‘i' || ch == ‘o’ || ch == ‘u’){ 
 System.out.println(ch + “ :  모음입니다.”); 
} else{ 
 System.out.println(ch + “ :  자음입니다.”); 
} 
i++; 
}

=>


String str = "banana";

for (char ch : str.toCharArray()) {
  switch (ch) {
    case 'a':
    case 'e':
    case 'i':
    case 'o':
    case 'u':
      System.out.println(ch + " : 모음입니다.");
      break;
    default:
      System.out.println(ch + " : 자음입니다.");
  }
}

20. 아래  코드를  while문, if문을  이용하여  같은  동작을  하는  코드로  변경하세요. 

for(int i = 1; i <= 20; i++){ 
 switch(i % 5){ 
 case 0: System.out.println(i + “ : 5의  배수입니다.”); break; 
 default: System.out.println(i + “ : 5의  배수가  아닙니다.”);   
} 
} 

=>

int i = 1;

while (i <= 20) {
  if (i % 5 == 0) {
    System.out.println(i + " : 5의 배수입니다.");
  } else {
    System.out.println(i + " : 5의 배수가 아닙니다.");
  }
  i++;
}
