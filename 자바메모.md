OOP (Object Oriented Programming)

객체는 자신의 속성(값, data)과 기능(동작,행동)을 가지고 있다

ex) 내가(객체) 마우스(객체)를 왼쪽, 오른쪽 버튼을 클릭하는 행위(상호작용)를 할 시 일어나는 일(이벤트)

이러한 객체와 객체간의 상호작용을 컴퓨터로 옮겨놓은게 객체지향 언어

자바의 클래스 하나 하나가 곧 객체

//

객체 지향 4대 특징

1. 캡슐화 (Encapsulation)
- 외부로부터 보호 + 그룹화


2. 상속 (Inheritance)
- 부모 코드를 자식 코드한테 물려주는 것
-> 자식은 본인의 코드를 가지고 있고 거기에 더 해 부모의 코드 또한 다 가지고 있다
-> 한 부모로부터 나온 코드는 모든 자식들이 가지고 있고, 부모의 코드가 바뀐다면 모든 자식들의 코드 또한 바뀐다

3. 다형성 (Polymorphism)
- A라는 코드가 다양한 결과를 낼 수 있다는 개념

4. 추상화 (Abstraction) 
- 추상적인 것 : 백동현x 사람o
 -> 사람의 특징을 나열하는 행위가 곧 추상화 작업 (나이, 주민등록번호, 이름 등 사람이 공통적으로 가지고 있는 것들의 나열)

//

객체 지향 언어 - 클래스

 클래스 : 객체가 가져야 할 속성(값), 기능(메서드)를
   		  글(코드)로 작성해둔 문서(설계도) == 객체를 정의한 것

//

캡슐화 : 클래스를 클래스명으로 감싸는 것 // 클래스의 가장 중요한 목적인 데이터의 직접 접근 제한을 원칙으로 함
        -> 부가 효과로 정보를 은닉한다(캡슐 내부의 정보를 외부에서 볼 수 없기 때문에)
        -> 매개변수와 반환을 통해 내부에 접근을 허용한다
//


------------------------- 정리 -------------------------

- 현실 객체: 현실 세계에서 인식할 수 있는 모든 것을 객체라고 합니다. 예를 들어, 사람, 동물, 차, 집 등이 모두 객체입니다. 
이들은 각각 고유의 속성과 행동을 가지고 있습니다.

- 객체 지향 언어: 객체 지향 언어는 프로그래밍 언어의 한 종류로, 프로그램을 객체들의 모임으로 보고, 
이 객체들이 서로 상호작용하면서 프로그램을 실행하는 방식을 말합니다. 자바, C++, 파이썬 등이 객체 지향 언어에 속합니다.

- 자바 객체: 자바에서 객체는 클래스로부터 생성됩니다. 객체는 클래스에서 정의된 속성과 메서드를 가지며, 
이를 통해 특정 작업을 수행합니다.

- 클래스: 클래스는 객체를 생성하기 위한 틀 또는 설계도로, 객체가 가져야 할 속성(값)과 기능(메서드)를 정의합니다.

- new 연산자: new 연산자는 자바에서 객체를 생성할 때 사용하는 연산자입니다. new 연산자를 사용하여 클래스의 *인스턴스를 생성하면, 
해당 클래스의 객체가 메모리에 할당됩니다.

- 추상화: 추상화는 복잡한 시스템을 간단한 개념으로 변환하는 것을 말합니다. 이를 통해 프로그램의 복잡성을 관리할 수 있습니다.

- 캡슐화: 캡슐화는 객체의 속성과 메서드를 하나로 묶고, 실제 구현 내용 일부를 외부에 감추는 것을 말합니다. 이를 통해 객체의 내부 데이터를 보호하고, 
외부에서는 해당 객체의 메서드만을 통해 접근할 수 있습니다.

- 캡슐화 원칙: 객체의 속성 직접 접근 차단
    1) private: private 키워드를 사용하여 클래스의 멤버 변수를 선언하면, 
    해당 변수는 해당 클래스 내에서만 접근이 가능합니다.
    2) 간접 접근 방법 작성: 간접 접근 방법은 getter와 setter 메서드를 통해 제공됩니다. 
    이 메서드들을 통해 객체의 속성에 안전하게 접근하고 수정할 수 있습니다.

heap 영역 할당 시 변수/요소가 빈칸으로 있을 수 없다!
-> 기본 값이 대입되어 있음

*클래스의 인스턴스 : 클래스의 인스턴스(instance)란, 클래스를 기반으로 생성된 객체를 말합니다. 
클래스는 객체를 생성하기 위한 틀 또는 설계도로, 객체가 가져야 할 속성(값)과 기능(메서드)를 정의합니다.
이 설계도를 바탕으로 실제 객체를 생성하는 과정을 인스턴스화(instantiation)라고 하며, 
이렇게 생성된 객체를 해당 클래스의 인스턴스라고 합니다. 각 인스턴스는 독립적으로 자신의 속성을 가지며, 클래스에 정의된 동일한 행동을 수행할 수 있습니다.
예를 들어, '자동차’라는 클래스가 있다면, 
이를 바탕으로 ‘포르쉐 911’, ‘테슬라 모델 S’ 등의 실제 자동차 객체를 생성할 수 있습니다. 
이런 각각의 자동차 객체는 ‘자동차’ 클래스의 인스턴스입니다. 
이들은 각각 독립적인 속성(색상, 모델명, 제조년도 등)을 가지며, 
주행, 정차 등의 동일한 행동을 수행할 수 있습니다. 

//

필드 == 객체의 속성
 -> 특별한 경우를 제외하고 캡슐화 원칙 적용

정적 : 생성 후 없어지지 않음
    => 프로그램이 실행될 때
    => static 키워드가 작성된 필드/메서드를
    => 메모리 영역에 생성
  [static 메모리 영역 == 정적 메모리 영역]
  * 언제 어디서든, 누구든지 접근 가능
    == 공유 메모리 영역

<->

동적 : 생성, 소멸
-> new 클래스명() : 객체 생성
-> 객체를 참조하는 변수가 없어짐(객체 소멸)

[heap 메모리 영역 == 동적 메모리 영역]

//

생성자 = 객체가 생성될 떄 수행되는 기능
-> 생성과 동시에 수행되어야 하는 기능이 있을 경우
-> 생성과 동시에 필드를 초기화 할 때

기본 생성자 public 클래스명(){}
매개변수 생성자 public 클래스명("네오", "권총");

this란? : 모든 인스턴스의 메서드에 숨겨진 채 존재하는 레퍼런스로, 할당된 객체를 가리킴
함수 실행 시 전달되는 객체의 주소를 자동으로 받음

//

함수(function)
- 프로그램에 정의된 기능(클래스 외부에 작성된 함수)

메서드(method)
- 객체가 가지고 있는 기능(클래스 내부에 작성된 함수)
 
메서드 반환형 메서드 종료시 반환되는 자료형
void :메서드가 아무런 값을 반환하지 않을 때 사용합니다.
기본 자료형 : `int`, `char`, `double`, `boolean` 등과 같은 기본 자료형을 반환할 때 사용합니다.
배열 : 메서드가 배열을 반환할 때 사용합니다. 예를 들어, `int[]`는 정수 배열을 반환합니다.
클래스 : 메서드가 특정 클래스의 인스턴스를 반환할 때 사용합니다. 예를 들어, `String`은 문자열 객체를 반환합니다.



객체(인스턴스) : new 연산자에 의해서 Heap 영역에 class 내용대로 생성(할당)된 것 

배열 : 객체 참조형 변수를 묶음으로 다루는 것 

//

상속(Inheritance) 요약

정의
상속은 한 클래스가 다른 클래스의 필드나 메서드를 사용할 수 있게 하는 기능입니다. 
이를 통해 코드의 재사용성이 높아지고, 관련된 클래스들 간의 공통적인 규약을 정의할 수 있습니다.

목적과 장점
상속의 주요 목적은 코드의 재사용성을 높이는 것입니다. 이로 인해 다음과 같은 장점이 있습니다:
1. 적은 양의 코드로 새로운 클래스를 작성할 수 있습니다.
2. 코드의 추가 및 변경이 용이합니다.
3. 코드의 중복을 제거하여 프로그램의 생산성과 유지보수에 크게 기여합니다.

방법
클래스 간의 상속은 `extends` 키워드를 사용하여 표현합니다. 예를 들어, 
`public class Academy extends Company {}`와 같이 사용합니다.

단일 상속과 다중 상속
자바에서는 단일 상속만을 지원합니다. 즉, 
한 클래스는 오직 하나의 부모 클래스만을 가질 수 있습니다. 
이는 클래스 간의 관계를 명확하게 하고 신뢰성 있는 코드를 작성하는 데 도움을 줍니다.

상속의 특징
1. 모든 클래스는 `Object` 클래스의 후손입니다. `Object` 클래스가 
제공하는 메서드를 오버라이딩하여 메서드를 재구현할 수 있습니다.
2. 부모 클래스의 생성자와 초기화 블록은 상속되지 않습니다. 자식 클래스가 생성될 때, 
부모 클래스의 생성자가 먼저 실행됩니다.
3. 부모의 `private` 멤버는 상속되지만 직접 접근할 수는 없습니다.

`super()`와 `super`
`super()`는 부모 객체의 생성자를 호출하는 메서드입니다. 
`super`는 상속을 통한 자식 클래스 정의 시 해당 자식 클래스의 부모 객체를 가리키는 참조변수입니다.

오버라이딩(Overriding)
오버라이딩은 자식 클래스가 상속 받은 부모 메서드를 재정의(재작성)하는 것입니다. 
메서드 이름, 매개변수, 리턴 타입이 동일해야 하며, 접근 제어자는 부모와 같거나 넓은 범위로 변경 가능합니다.

`final` 예약어
`final` 예약어는 상속이 불가능한 클래스를 정의하거나, 상속 시 오버라이딩이 
불가능한 메서드를 정의하는 데 사용됩니다.

대상에 따른 사용 가능한 제어자, 예약어
- 클래스: `public`, `(default)`, `final`, `abstract`
- 메서드: 모든 접근 제어자, `final`, `abstract`, `static`
- 변수: 모든 접근 제어자, `final`, `static`
- 지역변수: `final`

클래스에 `abstract`와 `final`을 동시에 사용할 수 없으며, 
메서드에 `static`과 `abstract`을 동시에 사용할 수 없습니다. 
또한, `abstract` 메서드의 접근 제어자로 `private`을 사용할 수 없습니다.

//

다형성 (Polymorphism)
자바에서 다형성은 한 타입의 참조 변수를 통해 여러 타입의 객체를 참조할 수 있도록 하는 것을 의미합니다. 
이는 하나의 객체가 여러 가지 형태를 가질 수 있는 것을 의미하는데, 이를 통해 같은
 자료형에 여러 가지 객체를 대입하여 다양한 결과를 얻어낼 수 있습니다. 

자바에서는 이러한 다형성을 부모 클래스 타입의 참조 변수로 자식 클래스
 타입의 인스턴스를 참조할 수 있도록 하여 구현하고 있습니다. 
이를 통해 하나의 타입으로 다양한 실행 결과를 얻을 수 있으며 객체를 부품화하여 유지 보수를 용이하게 합니다. 

다형성 구현 방법은 클래스의 상속이나 인터페이스를 구현하는 자식 
클래스에서 메서드를 재정의 (오버라이딩) 하고 자식 클래스를 부모 타입으로 
업캐스팅하여 부모 타입의 객체에서 자식 멤버를 참조하여 구현합니다.


Public class Iphone extends SmartPhone{}
SmartPhone s1 = new Iphone();

SmartPhone 부모 타입 참조 변수가 자식 객체인 Iphone 객체를 참조하는데,
 Iphone 객체 내부에는 부모인 SmartPhone 객체가 존재하므로 SmartPhone 참조 변수는 SmartPhone 객체만 참조한다 SmartPhone 참조 변수가 Iphone 내부의 SmartPhone만 참조 -> 자식인 Iphone 객체가 부모인 SmartPhone 객체로 변한 것 처럼 보인다. 이것이 다향성!


다형성은 객체 지향 프로그래밍에서 중요한 개념입니다. 다형성은 코드를 유연하게 만들어주며, 상속과 인터페이스를 통해 구현됩니다. 이를 이해하기 위해 몇 가지 개념을 살펴보겠습니다.

1. 상속 (Inheritance):
    - `Iphone` 클래스가 `SmartPhone` 클래스를 상속받았습니다. 이는 `Iphone`이 `SmartPhone`의 모든 기능과 속성을 상속받는다는 의미입니다.
    - 상속을 통해 코드를 재사용하고, 부모 클래스의 기능을 확장할 수 있습니다.

2. 참조 변수 (Reference Variables):
    - `s1`은 `SmartPhone` 타입의 참조 변수입니다. 그러나 실제로 `Iphone` 객체를 참조하고 있습니다.
    - 이것이 다형성의 핵심입니다. 부모 클래스 타입의 변수가 자식 클래스 객체를 참조할 수 있습니다.

3. 객체 내부의 객체 (Composition):
    - `Iphone` 객체 내부에는 부모 클래스인 `SmartPhone` 객체가 존재합니다.
    - 따라서 `s1`은 `Iphone`의 기능을 사용하면서도 `SmartPhone`의 기능도 접근할 수 있습니다.

이런 다형성을 통해 코드는 더 유연하고 확장 가능하며, 객체 간의 관계를 더 명확하게 표현할 수 있습니다. 자바에서는 이러한 다형성을 통해 코드를 더 효율적으로 작성할 수 있습니다.


instance of 연산자

현재 참조형 변수가 어떤 클래스 형의 객체 주소를 참조하고 있는지 확인 할 때 사용
클래스 타입이 맞으면 true, 맞지 않으면 false 반환

//

추상(Abstract)

추상 클래스 : 추상 메서드만 있는 클래스 
             추상 클래스는 객체 생성 불가능
추상 메서드 : 몸체 없는 메소드(이름만 정한 메서드 == 나중에 만들 예정인 메서드)

추상 클래스와 메서드는 언제 쓰이는가? : 


상속(Inheritance)
- 클래스가 다른 클래스의 필드나 메서드를 사용할 수 있게 하는 기능
- 코드의 재사용성을 높이고, 관련된 클래스들 간의 공통적인 규약을 정의
- 클래스 간의 상속은 extends 키워드를 사용
- 자바에서는 단일 상속만을 지원
- 모든 클래스는 Object 클래스의 후손
- 부모 클래스의 생성자와 초기화 블록은 상속되지 않음
- super()는 부모 객체의 생성자를 호출하는 메서드
- final 예약어는 상속이 불가능한 클래스를 정의하거나, 상속 시 오버라이딩이 불가능한 메서드를 정의하는 데 사용

다형성(Polymorphism)
- 한 타입의 참조 변수를 통해 여러 타입의 객체를 참조할 수 있도록 하는 것
- 하나의 객체가 여러 가지 형태를 가질 수 있음
- 부모 클래스 타입의 참조 변수로 자식 클래스 타입의 인스턴스를 참조할 수 있도록 구현
- 다형성 구현 방법은 클래스의 상속이나 인터페이스를 구현하는 자식 클래스에서 메서드를 재정의 (오버라이딩) 하고 자식 클래스를 부모 타입으로 업캐스팅하여 구현

instance of 연산자
- 현재 참조형 변수가 어떤 클래스 형의 객체 주소를 참조하고 있는지 확인 할 때 사용
- 클래스 타입이 맞으면 true, 맞지 않으면 false 반환

추상(Abstract)
- 추상 클래스 : 추상 메서드만 있는 클래스, 객체 생성 불가능
- 추상 메서드 : 몸체 없는 메소드(이름만 정한 메서드 == 나중에 만들 예정인 메서드)




추상 클래스 전제 조건 (상속, 다형성(업캐스팅))

추상 클래스 : 추상 메서드를 지닌 클래스
             -> 직접 객체 생성 불가능
             -> 부모 타입 참조 변수로는 사용 가능

추상 메서드 : 메서드 정의 코드 {} 가 없는 메서드
            -> 상속 받은 자식이 무조건 재정의
               (오버라이딩 강제화)

상속 받은 객체 생성 시 자식 객체 내 부모 부분에
존재하는 추상 메서드는 동적 바인딩에 의해 무시된다!!
    
자바에서 멤버란??? 필드에 있는 모든 메서드와 변수를 멤버라고 한다.

//

인터페이스
Interface(접점)
User Interface(사용자와의 접점)

클래스간의 접점을 만드는데 사용

클래스A / 클래스B는 아무런 관계도 없는 클래스들이지만
둘이 같은 부모를 공유할 경우 부모라는 접점이 생김

//

컬렉션(Collection)

자바에서 미리 만들어 제공하는 자료구조의 모음

기본 자료형 8가지를 객체화 할 수 있다. 이를 Wrapper 클래스라고 부름

자바 컬렉션 프레임 워크(Collection Framework) 3가지
List, Set, Map
이 세 가지의 후손도 여러가지가 있다

자바 패키지는 2가지 (List, Set)

List/Set의 공통 코드만 작성한 인터페이스(지을 이름이 없어서 그냥 Collection이라고 함)

자바 List 인터페이스 요약

 1. 객체 추가
- add(E e): 주어진 객체를 리스트의 끝에 추가합니다.
- add(int index, E element): 주어진 객체를 리스트의 특정 위치에 추가합니다.

 2. 객체 검색
- get(int index): 주어진 인덱스에 있는 객체를 리턴합니다.
- indexOf(Object o): 주어진 객체가 처음으로 나타나는 위치를 리턴합니다.
- lastIndexOf(Object o): 주어진 객체가 마지막으로 나타나는 위치를 리턴합니다.
- contains(Object o): 주어진 객체가 리스트에 있는지 확인합니다.
- isEmpty(): 리스트가 비어있는지 확인합니다.
- size(): 리스트에 있는 객체의 수를 리턴합니다.

 3. 객체 수정
- set(int index, E element): 주어진 인덱스에 있는 객체를 주어진 객체로 교체합니다.

 4. 객체 삭제
- clear(): 리스트에서 모든 객체를 삭제합니다.
- remove(int index): 주어진 인덱스에 있는 객체를 삭제합니다.
- remove(Object o): 주어진 객체를 리스트에서 삭제합니다.

Set : 집합
저장 순서가 유지되지 않고, 중복 객체도 저장하지 못하게 하는 자료 구조
null도 중복을 허용하지 않기 때문에 1개의 null만 저장

Set은 순서가 없고 중복된 요소를 허용하지 않는 컬렉션입니다. 데이터의 고유성을 유지해야 하는 경우에 유용합니다.

Set의 주요 특징:

순서 없음: Set에 저장된 요소들은 순서대로 저장되지 않습니다.
중복 허용하지 않음: Set에 같은 요소가 두 번 들어갈 수 없습니다.
빠른 검색: Set은 HashSet과 같은 해시 기반 구조를 사용하여 요소를 저장하기 때문에 검색 속도가 매우 빠릅니다.
Set의 주요 구현 클래스:

HashSet: 가장 일반적인 Set 구현 클래스입니다. 해시 테이블을 사용하여 요소를 저장합니다.
LinkedHashSet: HashSet과 유사하지만, 요소가 추가된 순서대로 유지됩니다.
TreeSet: 요소가 정렬된 순서대로 유지되는 Set입니다.


//

제네릭스(Generics) 타입 제한

//

1. **객체 비교**:
    - **동일성(Identity)**: 두 객체가 동일하다는 것은 두 객체가 메모리 상에서 같은 위치를 가리키고 있다는 것을 의미합니다.
    - **동등성(Equality)**: 두 객체가 동등하다는 것은 두 객체의 값이 같다는 것을 의미합니다.

2. **hashCode() 메서드**:
    - `hashCode()` 메서드는 객체별 식별 코드를 반환하는 메서드입니다. 이 식별 코드는 객체를 구분하는 정수 값입니다.
    - 예를 들어, 주민등록번호, 학번, 은행 번호표 등이 이에 해당합니다.

3. **hash 함수**:
    - hash 함수는 값을 입력하면 같은 길이의 문자열이 반환되는 함수입니다. 이는 암호화에 주로 사용됩니다.
    - 예를 들어, `123`을 입력하면 `qwerty`가 반환되고, `abcdefghi`를 입력하면 `asdfgh`가 반환됩니다.

4. **동일성과 동등성 비교**:
    - 객체의 동일성과 동등성을 비교하려면 `equals()`와 `hashCode()` 메서드를 사용해야 합니다.

//
컬렉션은
List > Map > Set 순으로 많이 쓰임

//

Map

키(key)와 값(value)으로 구성되어 있으며, 키와 값은 모두 객체
키는 중복 저장을 허용하지 않고(Set방식), 값은 중복 저장 가능(List방식)
키가 중복되는 경우, 기존에 있는 키에 해당하는 값을 덮어 씌움
구현 클래스로 HashMap, HashTable, LinkedHashMap, Properties, TreeMap이 있음

Map : 특정 키워드(Key)를 입력하면 해당되는 상세한 값(Value)를 얻을 수 있는 컬렉션 객체

 - K:V 형식으로 구성
 - K:V 한 쌍을 Entry라고 부름


	 Wrapper Class
	 - wrap : 감싸다, 포장하다
	 - 기본 자료형을 객체로 포장하는 클래스
	 -> 기본 자료형의 객체화
	 --> 왜? 컬렉션처럼 객체만 취급하는 상황에서 기본 자료형도
	 ---> 취급 가능한 형태로 바꾸기 위해서

	 Unboxing <-> Boxing

	 boolean <-> Boolean
	 byte <-> Byte
	 short <-> Short
	 int <-> Integer
	 long <-> Long
	 float <-> Float
	 double <-> Double
	 char <-> Character

	 * Boxing, Unboxing을 자동으로 수행되도록 구현되어 있음
	 -> AutoBoxing, AutoUnboxing

	 + Wrapper Class를 이용해 객체화 되었을 때
	 추가적인 필드, 기능을 제공함

//

String의 불변성 immutable

String을 "" 리터럴을 이용해 생성/수정하면 String Pool에 String 객체가 계속 새롭게 생성된다!
-> 수정으로 인해 참조 당하지 않는 String 객체가 바로 삭제되지 않기 때문에 메모리를 계속 차지하는 문제 발생!
--> JVM의 GC가 관리를 해주지만, 지워질 때까지 메모리가 낭비되는 문제가 발생하여 String의 수정을 권하지 않음

StringBuilder / StringBuffer 클래스

String의 불변성 문제를 해결한 클래스 -> 가변성(mutable)	 * 
기본 16글자 저장할 크기로 생성 저장되는 문자열의 길이에 따라 크기가 증가/감소
마음대로 문자열 수정, 삭제 가능!
StringBuilder : Thread Safe 미제공 (비동기, 추천)
StringBuffer : Thread Safe 제공 (동기)

여기서 주요 개념은 **불변성(Immutability)**과 **가변성(Mutability)**입니다.

**String** 클래스는 불변성을 가집니다. 즉, 한 번 생성된 String 객체는 그 값을 변경할 수 없습니다. "" 리터럴을 이용해 String을 생성/수정하면, 실제로는 String Pool에 새로운 String 객체가 계속 생성되는 것입니다. 이로 인해 참조되지 않는 String 객체가 메모리를 계속 차지하게 되는 문제가 발생합니다. 이러한 객체들은 JVM의 Garbage Collector에 의해 관리되지만, 그들이 실제로 삭제될 때까지 메모리가 낭비되는 문제가 있습니다. 이러한 이유로, String의 수정은 권장되지 않습니다.

반면에, **StringBuilder**와 **StringBuffer** 클래스는 String의 불변성 문제를 해결한 클래스로, 가변성을 가집니다. 이들 클래스는 기본적으로 16글자를 저장할 수 있는 크기로 생성되며, 저장되는 문자열의 길이에 따라 그 크기가 동적으로 증가/감소합니다. 따라서 이들 클래스를 사용하면 문자열을 마음대로 수정하거나 삭제할 수 있습니다.

StringBuilder와 StringBuffer의 주요 차이점은 **Thread Safe** 여부입니다. StringBuilder는 Thread Safe를 제공하지 않아 성능이 더 뛰어나므로 단일 스레드 환경에서 추천됩니다. 반면에 StringBuffer는 Thread Safe를 제공하므로 여러 스레드가 동시에 접근할 수 있는 환경에서 사용됩니다. 이러한 특성 때문에 StringBuffer는 동기화 비용이 발생하므로 성능이 StringBuilder보다 약간 떨어질 수 있습니다.

//

예외 처리(Exception Handling)

프로그램 수행 시 치명적 상황이 발생하여 비정상 종료 상황이 발생한 것, 프로그램 에러라고도 함

1. 컴파일 에러 : 프로그램의 실행을 막는 소스 코드상의 문법 에러.소스 코드 수정으로 해결.
2. 런타임 에러 : 프로그램 실행 중 발생하는 에러. 대부분 if문 사용으로 에러 처리 가능
    (ex. 배열의 인덱스 범위를 벗어났거나, 계산식의 오류)
3. 시스템 에러 : 컴퓨터 오작동으로 인한 에러, 소스 코드 수정으로 해결 불가

예외 처리 방법

try~catch문을 이용하여 예외 처리

-try: Exception 발생할 가능성이 있는 코드를 안에 기술

-catch: try 구문에서 Exception 발생 시 해당하는 Exception에 대한 처리 기술

여러 개의 Exception 처리가 가능하나 Exception간의 상속 관계 고려해야함

-finally: Exception 발생 여부와 관계없이 꼭 처리해야 하는 로직 기술
중간에 return문을 만나도 finally구문은 실행되지만
System.exit();를 만나면 무조건 프로그램 종료
주로 java.io나 java.sql패키지의 메소드 처리 시 이용

Checked Exception / Unchecked Exception

Checked Exception : 반드시 확인해야하는 예외
-> 예외 처리 구문(try-catch, throws)을 반드시!!! 작성해야되는 예외

Unchecked Exception : 확인 안해도 되는 예외
-> 예외 처리 구문을 써도 되고 안 써도 되는 예외(단, catch문을 if문 같이 써서 활용할 수도 있음)

부모 타입 예외 참조 변수 = 자식 타입 예외 객체
-> 다형성 업캐스팅(매개 변수)
unreachable catch block : 도달할 수 없는 catch 
자식 예외를 부모 catch문에서 모두 잡아서 처리하기 때문에
자식 catch문까지 코드가 도달할 수가 없다! (수행 불가, 죽은 코드)
-> 해결 방법 : 부모 catch(RuntimeException)를 자식보다 밑에두면 된다



throws : 메서드 내부에서 발생된 예외를 호출한 곳으로 던짐
throw  : 예외 객체를 현재 위치에서 던짐 (예외 강제 발생)


catch 구문에서의 e : 예외 객체 참조 
e.printStackTrace()
- print : 출력하다
- Stack : JVM 메모리 중 Stack 영역(메서드가 쌓여있음)
- Trace : 추적
-> 호출한 메서드 순서대로 발생한 예외를 모두 추적해서 출력(예외 발생 로그 출력)

입출력(IO)

Input과Output의 약자, 컴퓨터 내부 또는 외부 장치와 프로그램 간의 데이터를 주고 받는 것
장치와 입출력을 위해서는 하드웨어 장치에 직접 접근이 필요한데 다양한 매체에 존재하는 데이터들을
사용하기 위해 입출력 데이터를 처리할 공통적인 방법으로 스트림 이용

Steram : 흐르다

Stream은 한 방향으로 흐른다 내 자바 프로그램으로 받는 것이 input 외부로 내보내는게 output

/* File 클래스
	 * - java.io 패키지에 존재한다
	 * - 파일/디렉토리(폴더)를 관리하는 클래스
	 *   (파일/디렉토리 존재 유무 관계 없음)
	 * - 파일 생성, 제거, 이름, 크기, 마지막 수정일, 존재 여부 등의 기능 제공 
	 * 
	 * boolean  mkdir()          : 디렉토리 생성
	 * boolean  mkdirs()         : 경로상의 모든 디렉토리 생성
	 * boolean  createNewFile()  : 파일 생성
	 * boolean  delete()         : 파일/디렉토리 삭제
	 * String   getName()        : 파일 이름 반환
	 * String   parent()         : 파일이 저장된 디렉토리 반환
	 * String   getPath()        : 전체 경로 반환
	 * boolean  isFile()         : 현재 File 객체가 관리하는게 파일이면 true
	 * boolean  isDirectory      : 현재 File 객체가 관리하는게 디렉토리 true
	 * boolean  exists()         : 파일/디렉토리가 존재하면 true, 아님 false
	 * long     length()         : 파일 크기 반환
	 * long     lastModified()   : 파일 마지막 수정일 (1970.01.01 09:00 부터 현재까지 지난 시간을 ms 단위로 반환)
	 * String[] list()          : 디렉토리 내 파일 목록을 String[] 배열로 반환
	 * File[]   listFiles()     : 디렉토리 내 파일 목록을 File[] 배열로 반환 
	 * */
	
	// [개발자 상식]
	// OS : 운영 체제
	// 폴더(Windows) / 디렉토리(Linux, Mac)
	
	// - 경로 표기 방법(하위 폴더, 파일 표시)
	// 백슬래시(\ : Windows) C:\workspace\04_Java
	// 슬래시(/ : Linux, Mac) C:/workspace/04_Java
	
	// Java 언어의 특징 : 플랫폼(OS)에 독립적
	// -> OS 관계 없이 똑같은 코드 작성이 가능
	// --> 이 특징을 유지하기 위해 /, \ 둘다 호환 가능
	// ---> (런타임 시 실행되는 OS에 맞게 자동으로 변경)
	
	// ----------------------
	
	// - 경로 표기 방법
	// 1) 절대 경로 : 하나의 절대적인 기준으로부터 목표까지의 경로를 모두 표기하는 방법
	//							ex) [Windows] C:\workspace\04_Java
	//							ex) [Linux, Mac] /Users
	// 2) 상대 경로 : 현재 위치를 기준으로 목표까지의 경로를 표기하는 방법
	// 상황에 맞게 더 편한쪽으로 표기하면 된다.


1. **ObjectInputStream / ObjectOutputStream**: 이들은 Java에서 객체를 입/출력할 때 사용하는 바이트 기반의 보조 스트림입니다. 이들은 단독으로 사용할 수 없으며, 항상 다른 스트림과 함께 사용해야 합니다.

2. **Java 객체(Instance == Object)**: 이는 Java에서 데이터를 표현하는 기본 단위입니다. 객체는 클래스에 정의된 필드와 메소드를 가지며, 이를 통해 데이터를 저장하고 조작할 수 있습니다.

3. **직렬화(Serializable)**: 이는 객체를 직선 형태로 변환하는 과정을 의미합니다. 직렬화를 통해 객체는 네트워크를 통해 전송되거나 디스크에 저장될 수 있는 바이트 스트림으로 변환됩니다. 이 과정은 `ObjectOutputStream`의 `writeObject` 메소드를 통해 수행됩니다.

4. **보조 스트림**: 이는 기본 스트림에 추가 기능을 제공하는 스트림입니다. 보조 스트림은 단독으로 사용할 수 없으며, 항상 기본 스트림과 함께 사용해야 합니다. `ObjectInputStream`과 `ObjectOutputStream`은 바이트 기반의 보조 스트림의 예입니다.

이러한 개념들은 Java의 입/출력 및 직렬화에 중요한 역할을 합니다. 이들을 이해하면 Java에서 데이터를 효과적으로 관리하고 전송할 수 있습니다.

